<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>PDF Export Tool</title>

    <!-- html2pdf.js import -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            background-color: #ddddff;
        }

        #container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #styleControls {
            display: flex;
            flex-direction: column;
            width: 300px;
            min-height: 0;
            max-height: 100%;
            overflow: hidden;
            box-sizing: border-box;
            margin: 1em;
            background-color: #ddf;
        }

        #controlContainer {
            overflow-y: auto;
            flex-grow: 1;
            margin-bottom: 1em;
            border-top: 1px solid #ccc;
        }

        #functionButtons {
            margin: auto 1em 1em 1em;
            padding-top: 1em;
            border-top: 1px solid #ccc;
        }

        #fontSizeInput, #headerSizeInput {
            width: 3em;
        }

        #templateSelector {
            margin-bottom: 5px;
        }

        .styleBlock {
            position: relative;
            margin-top: 1em;
            margin-bottom: .5em;
            padding: 1em .5em .5em .5em;
            border: 1px solid #888;
            border-radius: 0.5em;
        }

        .styleBlock h3 {
            position: absolute;
            top: -0.75em;
            margin-top: 0;
            margin-bottom: 0.5em;
            padding-inline: 0.25em;
            background: #ddf
        }

        iframe {
            flex-grow: 1;
            border: 2px dashed #acf;
            border-radius: 8px;
            margin: 10px;
            height: calc(100% - 20px);
        }

        .choices {
            margin-bottom: 0;
        }
    </style>
</head>
<body>

<div id="container">
    <div style="display: flex;flex-direction: column;height: 100%;">
        <div id="styleControls">

        </div>
        <div id="functionButtons">
            <button style="display: none" onclick="printPreview()">Print Preview</button>
            <button style="display: none" onclick="saveAsPDF()">Save as PDF</button>
            <label for="templateSelector">Select Style Template:<br/>
                <select id="templateSelector" data-control="templateSelector"></select><br/></label>
            <button id="resetStyles">Reset to template</button>
        </div>
    </div>

    <iframe id="previewFrame"></iframe>

</div>

<script type="module">
    import {setDebug, debugLog} from "./scripts/debugLog.js";
    import {controlsReady} from "./scripts/controls.js";
    import {generateControl} from "./scripts/controls.js";
    import {sanitizeId} from "./scripts/utilities.js";

    const frame = getControl("previewFrame");
    frame.addEventListener('load',
        async () => {
            // Load templates from style-templates.json
            await parseJsonTemplates();
            // Populate the template selector dropdown **before** setting up style controls

            populateTemplateSelector();
            // Then setup controls, which reads from currentDefault and sets input values

            injectStyleSheet();
        }
    );
    frame.src = "Large HTML page with images.html";

    await controlsReady

    setDebug(true);

    class StyleTemplates {
        constructor(templates = []) {
            this.templates = templates; // Accept initial templates optionally
            this.setCurrentTemplate('Default');
        }

        // Return an array of all template names
        getTemplateNames() {
            return this.templates.map(template => template.name);
        }

        // Set currentDefault with fallback logic
        setCurrentTemplate(name) {
            const names = this.getTemplateNames();

            if (names.includes(name)) {
                this.currentDefault = name;
            } else if (names.includes('Default')) {
                this.currentDefault = 'Default';
            } else if (names.length > 0) {
                this.currentDefault = names[0];
            } else {
                this.currentDefault = null;
            }
        }

        getCurrentTemplate() {
            return this.templates.find(t => t.name === this.currentDefault) || null;
        }
    }

    function createStyleTemplatesProxy(styleTemplatesInstance) {
        return new Proxy(styleTemplatesInstance, {
            get(target, prop, receiver) {
                // If prop is a real method or property of the class, use it
                if (prop in target) {
                    return Reflect.get(target, prop, receiver);
                }

                // Otherwise, try to fetch from the current template
                const current = target.getCurrentTemplate();
                if (current && prop in current) {
                    return current[prop];
                }

                return undefined;
            }
        });
    }

    async function loadJsonFile(filename) {
        try {
            const response = await fetch(filename);
            if (response.ok) {
                const jsonString = await response.text();
                return JSON.parse(jsonString);
            } else {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
        } catch (error) {
            console.error("Error loading or parsing JSON file:", error);
            throw error;
        }
    }

    let styleTemplates; // Object to hold style templates loaded from the style-templates.json file

    function getControl(id) {
        const el = document.getElementById(id);
        if (!el) {
            console.warn(`Missing control: #${id}`);
        }
        return el;
    }

    async function parseJsonTemplates() {
        try {
            const jsonData = await loadJsonFile('style-templates.json');

            let styleTemplatesRaw = new StyleTemplates();
            styleTemplates = createStyleTemplatesProxy(styleTemplatesRaw);

            jsonData.templates.forEach(template => {
                styleTemplates.templates.push(structuredClone(template));
            });
        } catch (error) {
            console.error("Failed to parse style templates:", error);
        }
    }

    function populateControls() {
        const currentTemplate = styleTemplates.getCurrentTemplate();
        const styleControlsDiv = document.getElementById('styleControls');
        styleControlsDiv.innerHTML = '';

        const tabs = styleControlsDiv.appendChild(generateControl('RadioTabs', 'radioTabs'));
        const controlContainerDiv = styleControlsDiv.appendChild(document.createElement('div'));
        controlContainerDiv.id = 'controlContainer';

        for (const group of currentTemplate.groups) {
            const groupContainerDiv = document.createElement('div');
            groupContainerDiv.dataset.group = sanitizeId(group.name);
            tabs.appendTab(group.name);

            for (const section of group.sections) {
                const sectionContainerDiv = document.createElement('div')
                sectionContainerDiv.classList.add('styleBlock');
                const sectionName = section.name;
                const h3 = sectionContainerDiv.appendChild(document.createElement('h3'));
                h3.innerText = sectionName;
                Object.entries(section).forEach(([cssSelector, params]) => {
                    if (cssSelector !== 'name') {
                        Object.entries(params).forEach(([cssProperty, params]) => {
                            if (cssProperty !== 'name') {
                                const control = generateControl(params.type, cssSelector, cssProperty);
                                sectionContainerDiv.appendChild(control);
                                control.setDefaults(params, true);
                                control.locked = params.locked ?? false;
                                control.label = params.label ?? '';
                                control.dataset.providesStyle = true.toString();

                                control.addEventListener('change', applyStyles);
                            }
                        });
                    }
                });
                groupContainerDiv.appendChild(sectionContainerDiv);
            }
            controlContainerDiv.appendChild(groupContainerDiv);
        }
        tabs.tabStyles.height = "70px";
        tabs.addEventListener('change', () => {
            const selected = sanitizeId(tabs.value); // get the currently selected tab value
            const groups = document.querySelectorAll('[data-group]');
            groups.forEach(group => {
                if (group.dataset.group === selected) {
                    group.style.display = '';   // show matching group(s)
                } else {
                    group.style.display = 'none';  // hide others
                }
            });
        });
        tabs.dispatchEvent(new Event('change'));
    }

    function injectStyleSheet() {
        const doc = frame.contentDocument || frame.contentWindow.document;

        // Make the default background white instead of transparent
        let bgColor = doc.createElement('style')
        bgColor.innerHTML = "html { background-color: white }";
        doc.head.prepend(bgColor);

        // Add the style tag if it doesn't exist
        if (!doc.getElementById("dynamic-style")) {
            const style = doc.createElement("style");
            style.id = "dynamic-style";
            style.setAttribute("data-style-marker", "dynamic")
            doc.head.appendChild(style);
        }

        // Inject Google Fonts
        if (!doc.getElementById("google-fonts")) {
            doc.head.appendChild(
                Object.assign(doc.createElement('link'), {
                    rel: 'preconnect',
                    href: 'https://fonts.googleapis.com'
                })
            );
            const prelink = doc.createElement('link');
            Object.assign(prelink, {
                rel: 'preconnect',
                href: 'https://fonts.gstatic.com'
            });
            prelink.setAttribute('crossorigin', '');
            doc.head.appendChild(prelink);
            const link = doc.createElement("link");
            link.id = "google-fonts";
            link.rel = "stylesheet";
            link.href = "https://fonts.googleapis.com/css2?family=Domine&family=Inconsolata&family=Lora&family=Merriweather:opsz@18..144&family=Open+Sans&family=Roboto&display=swap";
            link.onload = setupStyleControls; // Wait for fonts to load
            doc.head.appendChild(link);
        } else {
            setupStyleControls(); // Fonts already there
        }
    }

    function populateTemplateSelector() {
        // Clear existing options (if any)
        let selector = document.getElementById("templateSelector");
        selector.innerHTML = "";

        const names = styleTemplates.getTemplateNames();

        // If currentDefault is null or falsy, call setCurrentTemplate() with no args for fallback
        if (!styleTemplates.currentDefault) {
            styleTemplates.setCurrentTemplate();
        }

        // Add options to the dropdown
        names.forEach(name => {
            const option = document.createElement("option");
            option.value = name.toString();
            option.textContent = name.toString();
            selector.appendChild(option);
        });

        // Set the dropdown's selected value to currentDefault (might still be null if no templates)
        if (styleTemplates.currentDefault && names.includes(styleTemplates.currentDefault)) {
            selector.value = styleTemplates.currentDefault;
        } else if (names.length > 0) {
            selector.value = names[0];
        }

        // Call once to sync constraints on an initial load
        populateControls();

        // Add change event listener after populating options
        selector.addEventListener("change", () => {
            const selected = selector.value;
            styleTemplates.setCurrentTemplate(selected);
            populateControls();
            applyStyles();
        });
    }

    function applyStyles() {
        const doc = frame.contentDocument || frame.contentWindow.document;
        const style = doc.getElementById("dynamic-style");

        // Get all controls from the main document
        const validControls = [...document.querySelectorAll('[data-provides-style]')];

        // Group declarations by CSS selector
        const grouped = {};

        for (const el of validControls) {
            const selector = el.cssSelector;
            const declaration = el.cssDeclaration;

            if (!grouped[selector]) {
                grouped[selector] = [];
            }

            grouped[selector].push(declaration);
        }

        // Construct final stylesheet text
        // Inject into the iframe or other `doc`
        style.textContent = Object.entries(grouped)
            .map(([selector, declarations]) => `${selector} {\n  ${declarations.join(';\n  ')};\n}`)
            .join('\n\n');
    }

    function resetStyleControls() {
        const tabs = document.getElementById('radioTabs');
        const selectedTab = tabs?.value;
        populateControls();
        const newTabs = document.getElementById('radioTabs');
        if (selectedTab) {
            newTabs.value = selectedTab;
            newTabs.dispatchEvent(new Event('change'));
        }

        applyStyles();
    }

    function setupStyleControls() {
        getControl("resetStyles").addEventListener("click", resetStyleControls);

        resetStyleControls();
    }

    function printPreview() {
        frame.contentWindow.focus();
        frame.contentWindow.print();
    }

    function saveAsPDF() {
        const srcDoc = frame.contentDocument || frame.contentWindow.document;
        const clonedDoc = srcDoc.documentElement.cloneNode(true);

        // Create a new print window
        const printWindow = window.open('', '_blank', 'width=800,height=600');

        if (!printWindow) {
            alert("Popup blocked. Please allow popups for this site.");
            return;
        }

        const printDoc = printWindow.document;
        printDoc.open();
        printDoc.write('<!DOCTYPE html><html lang="en"><head><title>Print Preview</title>');

        // Include any necessary stylesheets here
        const dynamicStyle = srcDoc.getElementById("dynamic-style");
        if (dynamicStyle) {
            printDoc.write(`<style>${dynamicStyle.textContent}</style>`);
        }

        // Optional: Add a print-specific style
        printDoc.write(`
        <style>
            @media print {
                body {
                    margin: 1in;
                }
            }
        </style>
    `);

        printDoc.write('</head><body>');
        printDoc.write(clonedDoc.querySelector('body').innerHTML);
        printDoc.write('</body></html>');
        printDoc.close();

        // Give it a moment to render
        printWindow.onload = () => {
            printWindow.focus();
            printWindow.print();
        };
    }
</script>

</body>
</html>
