<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>PDF Export Tool</title>

    <!-- html2pdf.js import -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <!-- Google Fonts (example set) -->

    <link href="https://fonts.googleapis.com/css2?family=Roboto&family=Open+Sans&family=Merriweather&family=Inconsolata&display=swap"
          rel="stylesheet">

    <!-- Choices.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css"/>

    <style>
        body {
            font-family: sans-serif;
            background-color: #f8f8f8;
            margin: 2em;
        }

        #container {
            display: flex;
            gap: 1em;
        }

        #styleControls {
            flex: 0 0 250px;
            padding: .5em;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 0.5em;
        }

        #fontSizeInput, #headerSizeInput {
            width: 3em;
        }

        .styleBlock {
            border: 1px solid #888;
            border-radius: 0.5em;
            padding: .5em;
            margin-bottom: .5em;
        }

        .styleBlock h3 {
            margin-bottom: 0.5em;
            margin-top: 0;
        }

        iframe {
            flex-grow: 1;
            height: 600px;
            border: 1px solid #ccc;
            background: #fff;
        }

        .choices {
            margin-bottom: 0;
        }
    </style>
</head>
<body>

<h1>PDF Export Tool</h1>
<div id="container">
    <script type="application/json" id="style-defaults">
        {
            "font": {
                "min": 0.5,
                "max": 3,
                "step": 0.1,
                "default": 1,
                "color": "#000000",
                "family": "sans-serif"
            },
            "header": {
                "min": 0.5,
                "max": 5,
                "step": 0.1,
                "default": 2,
                "color": "#000000",
                "family": "sans-serif"
            }
        }
    </script>

    <div id="styleControls">
        <div class="styleBlock">
            <h3>Page settings</h3>
            <label for="fontSize">Font Size: <input type="number" id="fontSizeInput"><span
                    id="fontSizeUnit">Ã—</span></label><br/>
            <input type="range" id="fontSize"/>

            <br/><br/>
            <label for="fontFamily">Font Family:</label>
            <select id="fontFamily">
                <option value="sans-serif">Sans</option>
                <option value="serif">Serif</option>
                <option value="monospace">Monospace</option>
                <option value="'Roboto', sans-serif">Roboto</option>
                <option value="'Open Sans', sans-serif">Open Sans</option>
                <option value="'Merriweather', serif">Merriweather</option>
                <option value="'Inconsolata', monospace">Inconsolata</option>
                <!-- Add more fonts here -->
            </select>
            <br/>
            <label>Text Color: <input type="color" id="textColor"/></label>
        </div>
        <div class="styleBlock">
            <h3>Header settings</h3>
            <label for="headerSize">Font Size: <input type="number" id="headerSizeInput"><span
                    id="headerSizeUnit">Ã—</span></label><br/>
            <input type="range" id="headerSize"/>

            <br/><br/>
            <label for="headerFamily">Font Family:</label>
            <select id="headerFamily">
                <option value="sans-serif">Sans</option>
                <option value="serif">Serif</option>
                <option value="monospace">Monospace</option>
                <option value="'Roboto', sans-serif">Roboto</option>
                <option value="'Open Sans', sans-serif">Open Sans</option>
                <option value="'Merriweather', serif">Merriweather</option>
                <option value="'Inconsolata', monospace">Inconsolata</option>
                <!-- Add more fonts here -->
            </select>
            <br/>
            <label for="headerColor">Text Color: </label>
            <input type="color" id="headerColor"/>
        </div>

        <button onclick="printPreview()">Print Preview</button>
        <button onclick="saveAsPDF()">Save as PDF</button>
        <br/><br/>
        <button id="resetStyles">Reset</button>

    </div>

    <iframe id="previewFrame"></iframe>
</div>

<script>
    /**
     * @typedef {Object} SizeSetting
     * @property {number} min
     * @property {number} max
     * @property {number} step
     * @property {number} default
     * @property {boolean} locked
     */

    /**
     * @typedef {Object} ColorSetting
     * @property {string} default
     * @property {boolean} locked
     */

    /**
     * @typedef {Object} FamilySetting
     * @property {string} default
     * @property {boolean} locked
     */

    /**
     * @typedef {Object} StyleSheetType
     * @property {SizeSetting} size
     * @property {ColorSetting} color
     * @property {FamilySetting} family
     */


    /**
     * @class
     */
    class StyleSheet {
        /**
         * @param {string} name
         * @param {StyleSheetType} settings
         */
        constructor(name, settings) {
            this.name = name;
            this.size = settings.size;
            this.color = settings.color;
            this.family = settings.family;
        }

        clamp(value) {
            return Math.min(Math.max(value, this.size.min), this.size.max);
        }
    }

    class StyleTemplates {
        constructor(templates = []) {
            this.templates = templates; // Accept initial templates optionally
            this.setCurrentTemplate('Default');
        }

        // Return an array of all template names
        getTemplateNames() {
            return this.templates.map(template => template.name);
        }

        // Set currentDefault with fallback logic
        setCurrentTemplate(name) {
            const names = this.getTemplateNames();

            if (names.includes(name)) {
                this.currentDefault = name;
            } else if (names.includes('Default')) {
                this.currentDefault = 'Default';
            } else if (names.length > 0) {
                this.currentDefault = names[0];
            } else {
                this.currentDefault = null;
            }
        }

        getCurrentTemplate() {
            return this.templates.find(t => t.name === this.currentDefault) || null;
        }
    }

    function createStyleTemplatesProxy(styleTemplatesInstance) {
        return new Proxy(styleTemplatesInstance, {
            get(target, prop, receiver) {
                // If prop is a real method or property of the class, use it
                if (prop in target) {
                    return Reflect.get(target, prop, receiver);
                }

                // Otherwise, try to fetch from the current template
                const current = target.getCurrentTemplate();
                if (current && prop in current) {
                    return current[prop];
                }

                return undefined;
            }
        });
    }

    async function loadJsonFile(filename) {
        try {
            const response = await fetch(filename);
            if (response.ok) {
                const jsonString = await response.text();
                return JSON.parse(jsonString);
            } else {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
        } catch (error) {
            console.error("Error loading or parsing JSON file:", error);
            throw error;
        }
    }

    let styleTemplates;

    async function parseJsonTemplate() {
        try {
            const jsonData = await loadJsonFile('style-templates.json');

            // Create a new StyleTemplates object
            let styleTemplatesRaw = new StyleTemplates();
            styleTemplates = createStyleTemplatesProxy(styleTemplatesRaw);

            // Iterate over each template
            jsonData.templates.forEach(template => {
                const page = new StyleSheet("page", template.page);
                const header = new StyleSheet("header", template.header);
                styleTemplates.templates.push({
                    name: template.name,
                    page,
                    header
                });

                // Set default config if it's named "default"
                if (template.name.toLowerCase() === "default") {
                    fontConfig = page;
                    headerConfig = header;
                    styleTemplates.currentDefault = template.name;
                }
            });

            console.log("Templates loaded:", styleTemplates);
        } catch (error) {
            console.error("Failed to parse style templates:", error);
        }
    }

    const configData = JSON.parse(document.getElementById("style-defaults").textContent);
    let fontConfig = new StyleSheet("font", configData.font);
    let headerConfig = new StyleSheet("header", configData.header);

    const frame = document.getElementById("previewFrame");
    window.onload = () => {
        frame.src = "Large HTML page with images.html";
        frame.onload = async () => {
            await parseJsonTemplate();
            injectStyleSheet();
        };

    };

    function injectStyleSheet() {
        const doc = frame.contentDocument || frame.contentWindow.document;

        // Add the style tag if it doesn't exist
        if (!doc.getElementById("dynamic-style")) {
            const style = doc.createElement("style");
            style.id = "dynamic-style";
            style.setAttribute("data-style-marker", "dynamic")
            doc.head.appendChild(style);

        }

        // Inject Google Fonts
        if (!doc.getElementById("google-fonts")) {
            const link = doc.createElement("link");
            link.id = "google-fonts";
            link.rel = "stylesheet";
            link.href = "https://fonts.googleapis.com/css2?family=Roboto&family=Open+Sans&family=Merriweather&family=Inconsolata&display=swap";
            link.onload = setupStyleControls; // ðŸŸ¢ Wait for fonts to load
            doc.head.appendChild(link);
        } else {
            setupStyleControls(); // Fonts already there
        }
    }

    function findStyleSheetWithMarker(doc) {
        for (let i = 0; i < doc.styleSheets.length; i++) {
            const sheet = doc.styleSheets[i];
            try {
                if (sheet.ownerNode?.getAttribute("data-style-marker") === "dynamic") {
                    return sheet;
                }
            } catch (e) {
                console.warn("Could not access stylesheet:", sheet.href, e);
            }
        }
        return null;
    }

    function setupStyleControls() {
        const doc = frame.contentDocument || frame.contentWindow.document;

        const fontSize = document.getElementById("fontSize");
        const fontSizeInput = document.getElementById("fontSizeInput");
        const fontFamily = document.getElementById("fontFamily");
        const textColor = document.getElementById("textColor");

        const headerSize = document.getElementById("headerSize");
        const headerSizeInput = document.getElementById("headerSizeInput");
        const headerFamily = document.getElementById("headerFamily");
        const headerColor = document.getElementById("headerColor");

        // Font size range + input
        fontSize.min = fontConfig.size.min;
        fontSize.max = fontConfig.size.max;
        fontSize.step = fontConfig.size.step;
        fontSize.value = fontConfig.size.default;
        fontSizeInput.min = fontConfig.size.min;
        fontSizeInput.max = fontConfig.size.max;
        fontSizeInput.step = fontConfig.size.step;
        fontSizeInput.value = fontConfig.size.default;

        // Header size range + input
        headerSize.min = headerConfig.size.min;
        headerSize.max = headerConfig.size.max;
        headerSize.step = headerConfig.size.step;
        headerSize.value = headerConfig.size.default;
        headerSizeInput.min = headerConfig.size.min;
        headerSizeInput.max = headerConfig.size.max;
        headerSizeInput.step = headerConfig.size.step;
        headerSizeInput.value = headerConfig.size.default;

        // Colors
        textColor.value = fontConfig.color.default;
        headerColor.value = headerConfig.color.default;

        // Font families (dropdowns)
        fontFamilyChoices.setChoiceByValue(fontConfig.family.default);
        headerFamilyChoices.setChoiceByValue(headerConfig.family.default);

        const applyStyles = () => {
            const style = doc.getElementById("dynamic-style");
            style.textContent = `
        body {
          font-size: ${fontSize.value}em;
          font-family: ${fontFamily.value};
          color: ${textColor.value};
        }

        h1 {
          font-size: ${headerSize.value}em;
          font-family: ${headerFamily.value};
          color: ${headerColor.value};
        }`;
        };

        const updateStyle = () => {
            applyStyles();
        };

        function resetStyleControls() {
            fontSize.value = fontConfig.size.default;
            fontSizeInput.value = fontConfig.size.default;
            headerSize.value = headerConfig.size.default;
            headerSizeInput.value = headerConfig.size.default;

            textColor.value = fontConfig.color.default;
            headerColor.value = headerConfig.color.default;

            fontFamilyChoices.setChoiceByValue(fontConfig.family.default);
            headerFamilyChoices.setChoiceByValue(headerConfig.family.default);

            updateStyle();
        }

        document.getElementById("resetStyles").addEventListener("click", resetStyleControls);

        fontSize.addEventListener("input", () => {
            fontSizeInput.value = fontSize.value;
            updateStyle();
        });
        fontSizeInput.addEventListener("change", () => {
            fontSizeInput.value = fontConfig.clamp(parseFloat(fontSizeInput.value));
            fontSize.value = fontSizeInput.value;
            updateStyle();
        });

        textColor.addEventListener("input", updateStyle);
        fontFamily.addEventListener("change", updateStyle);

        headerSize.addEventListener("input", () => {
            headerSizeInput.value = headerSize.value;
            updateStyle();
        });
        headerSizeInput.addEventListener("change", () => {
            headerSizeInput.value = headerConfig.clamp(parseFloat(headerSizeInput.value));
            headerSize.value = headerSizeInput.value;
            updateStyle();
        });

        headerColor.addEventListener("input", updateStyle);
        headerFamily.addEventListener("change", updateStyle);
    }

    function printPreview() {
        frame.contentWindow.focus();
        frame.contentWindow.print();
    }

    function saveAsPDF() {
        const srcDoc = frame.contentDocument || frame.contentWindow.document;
        const clonedDoc = srcDoc.documentElement.cloneNode(true);

        // Create a new print window
        const printWindow = window.open('', '_blank', 'width=800,height=600');

        if (!printWindow) {
            alert("Popup blocked. Please allow popups for this site.");
            return;
        }

        const printDoc = printWindow.document;
        printDoc.open();
        printDoc.write('<!DOCTYPE html><html lang="en"><head><title>Print Preview</title>');

        // Include any necessary stylesheets here
        const dynamicStyle = srcDoc.getElementById("dynamic-style");
        if (dynamicStyle) {
            printDoc.write(`<style>${dynamicStyle.textContent}</style>`);
        }

        // Optional: Add a print-specific style
        printDoc.write(`
        <style>
            @media print {
                body {
                    margin: 1in;
                }
            }
        </style>
    `);

        printDoc.write('</head><body>');
        printDoc.write(clonedDoc.querySelector('body').innerHTML);
        printDoc.write('</body></html>');
        printDoc.close();

        // Give it a moment to render
        printWindow.onload = () => {
            printWindow.focus();
            printWindow.print();
        };
    }
</script>

<script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>
<script>
    // Declare in global scope
    let fontFamilyChoices;
    let headerFamilyChoices;

    document.addEventListener("DOMContentLoaded", function () {
        fontFamilyChoices = new Choices("#fontFamily", {
            searchEnabled: true,
            itemSelectText: "",
            shouldSort: true
        });

        headerFamilyChoices = new Choices("#headerFamily", {
            searchEnabled: true,
            itemSelectText: "",
            shouldSort: true
        });
    });
</script>

</body>
</html>
