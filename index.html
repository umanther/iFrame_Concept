<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>PDF Export Tool</title>

    <!-- html2pdf.js import -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <!-- Google Fonts (example set) -->

    <link href="https://fonts.googleapis.com/css2?family=Roboto&family=Open+Sans&family=Merriweather&family=Inconsolata&display=swap"
          rel="stylesheet">

    <!-- Choices.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css"/>

    <style>
        body {
            font-family: sans-serif;
            background-color: #f8f8f8;
            margin: 2em;
        }

        #container {
            display: flex;
            gap: 1em;
        }

        #styleControls {
            flex: 0 0 250px;
            padding: .5em;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 0.5em;
        }

        #fontSizeInput, #headerSizeInput {
            width: 3em;
        }

        #templateSelector {
            margin-bottom: 5px;
        }

        .styleBlock {
            border: 1px solid #888;
            border-radius: 0.5em;
            padding: .5em;
            margin-bottom: .5em;
        }

        .styleBlock h3 {
            margin-bottom: 0.5em;
            margin-top: 0;
        }

        iframe {
            flex-grow: 1;
            height: 600px;
            border: 1px solid #ccc;
            background: #fff;
        }

        .choices {
            margin-bottom: 0;
        }
    </style>
</head>
<body>

<h1>PDF Export Tool</h1>
<div id="container">
    <div id="styleControls">
        <div class="styleBlock">
            <h3>Page settings</h3>
            <label for="fontSize">Font Size:
                <input type="number" id="fontSizeInput" data-control="fontSizeInput">
                <span id="fontSizeUnit">Ã—</span><br/>
                <input type="range" id="fontSize" data-control="fontSize"/></label>

            <br/><br/>
            <label for="fontFamily">Font Family:
                <select id="fontFamily" data-control="fontFamily">
                    <option value="sans-serif">Sans</option>
                    <option value="serif">Serif</option>
                    <option value="'Times New Roman', serif">Times New Roman</option>
                    <option value="monospace">Monospace</option>
                    <option value="'Roboto', sans-serif">Roboto</option>
                    <option value="'Open Sans', sans-serif">Open Sans</option>
                    <option value="'Merriweather', serif">Merriweather</option>
                    <option value="'Inconsolata', monospace">Inconsolata</option>
                    <!-- Add more fonts here -->
                </select></label>
            <br/>
            <label for="fontColor">Text Color:
                <input type="color" id="fontColor" data-control="fontColor"/></label>
        </div>
        <div class="styleBlock">
            <h3>Header settings</h3>
            <label for="headerSize">Font Size:
                <input type="number" id="headerSizeInput" data-control="headerSizeInput">
                <span id="headerSizeUnit">Ã—</span><br/>
                <input type="range" id="headerSize" data-control="headerSize"/></label>

            <br/><br/>
            <label for="headerFamily">Font Family:
                <select id="headerFamily" data-control="headerFamily">
                    <option value="sans-serif">Sans</option>
                    <option value="serif">Serif</option>
                    <option value="'Times New Roman', serif">Times New Roman</option>
                    <option value="monospace">Monospace</option>
                    <option value="'Roboto', sans-serif">Roboto</option>
                    <option value="'Open Sans', sans-serif">Open Sans</option>
                    <option value="'Merriweather', serif">Merriweather</option>
                    <option value="'Inconsolata', monospace">Inconsolata</option>
                    <!-- Add more fonts here -->
                </select>
            </label>
            <br/>
            <label for="headerColor">Text Color:
                <input type="color" id="headerColor" data-control="headerColor"/></label>
        </div>

        <button onclick="printPreview()">Print Preview</button>
        <button onclick="saveAsPDF()">Save as PDF</button>
        <br/><br/>
        <label for="templateSelector">Select Style Template:<br/>
            <select id="templateSelector" data-control="templateSelector"></select><br/></label>
        <button id="resetStyles">Reset to template</button>

    </div>

    <iframe id="previewFrame"></iframe>
</div>

<script>
    class StyleTemplates {
        constructor(templates = []) {
            this.templates = templates; // Accept initial templates optionally
            this.setCurrentTemplate('Default');
        }

        // Return an array of all template names
        getTemplateNames() {
            return this.templates.map(template => template.name);
        }

        // Set currentDefault with fallback logic
        setCurrentTemplate(name) {
            const names = this.getTemplateNames();

            if (names.includes(name)) {
                this.currentDefault = name;
            } else if (names.includes('Default')) {
                this.currentDefault = 'Default';
            } else if (names.length > 0) {
                this.currentDefault = names[0];
            } else {
                this.currentDefault = null;
            }
        }

        getCurrentTemplate() {
            return this.templates.find(t => t.name === this.currentDefault) || null;
        }
    }

    function createStyleTemplatesProxy(styleTemplatesInstance) {
        return new Proxy(styleTemplatesInstance, {
            get(target, prop, receiver) {
                // If prop is a real method or property of the class, use it
                if (prop in target) {
                    return Reflect.get(target, prop, receiver);
                }

                // Otherwise, try to fetch from the current template
                const current = target.getCurrentTemplate();
                if (current && prop in current) {
                    return current[prop];
                }

                return undefined;
            }
        });
    }

    async function loadJsonFile(filename) {
        try {
            const response = await fetch(filename);
            if (response.ok) {
                const jsonString = await response.text();
                return JSON.parse(jsonString);
            } else {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
        } catch (error) {
            console.error("Error loading or parsing JSON file:", error);
            throw error;
        }
    }

    let styleTemplates; // Object to hold style templates loaded from the style-templates.json file
    let controls; // Object to hold in-page control references

    function getControl(id) {
        const el = document.getElementById(id);
        if (!el) {
            console.warn(`Missing control: #${id}`);
        }
        return el;
    }

    async function parseJsonTemplate() {
        function addClampIfNeeded(section) {
            if (
                section &&
                section.size &&
                typeof section.size.min === "number" &&
                typeof section.size.max === "number"
            ) {
                section.clamp = function (value) {
                    return Math.min(Math.max(value, this.size.min), this.size.max);
                };
            }
        }

        try {
            const jsonData = await loadJsonFile('style-templates.json');

            // Create a new StyleTemplates object
            let styleTemplatesRaw = new StyleTemplates();
            styleTemplates = createStyleTemplatesProxy(styleTemplatesRaw);

            // Iterate over each template
            jsonData.templates.forEach(template => {
                const processed = {name: template.name};

                Object.entries(template).forEach(([sectionName, sectionData]) => {
                    if (sectionName === "name") return;

                    const section = structuredClone(sectionData);
                    addClampIfNeeded(section);
                    processed[sectionName] = section;
                });

                styleTemplates.templates.push(processed);
            });
        } catch
            (error) {
            console.error("Failed to parse style templates:", error);
        }
    }

    function populateControls() {
        controls = Object.freeze(
            Object.fromEntries(
                Array.from(document.querySelectorAll("[data-control]")).map(el => [el.dataset.control, el])
            )
        );
        console.log("Controls loaded:", controls);
    }

    const frame = getControl("previewFrame");

    window.onload = () => {
        frame.src = "Large HTML page with images.html";
        frame.onload = async () => {
            await parseJsonTemplate();

            // Populate the controls object with in-page controls for use in later functions
            populateControls();

            // Populate the template selector dropdown **before** setting up style controls
            populateTemplateSelector();

            // Then setup controls, which reads from currentDefault and sets input values
            injectStyleSheet();
        };

    };

    function injectStyleSheet() {
        const doc = frame.contentDocument || frame.contentWindow.document;

        // Add the style tag if it doesn't exist
        if (!doc.getElementById("dynamic-style")) {
            const style = doc.createElement("style");
            style.id = "dynamic-style";
            style.setAttribute("data-style-marker", "dynamic")
            doc.head.appendChild(style);
        }

        // Inject Google Fonts
        if (!doc.getElementById("google-fonts")) {
            const link = doc.createElement("link");
            link.id = "google-fonts";
            link.rel = "stylesheet";
            link.href = "https://fonts.googleapis.com/css2?family=Roboto&family=Open+Sans&family=Merriweather&family=Inconsolata&display=swap";
            link.onload = setupStyleControls; // ðŸŸ¢ Wait for fonts to load
            doc.head.appendChild(link);
        } else {
            setupStyleControls(); // Fonts already there
        }
    }

    // function findStyleSheetWithMarker(doc) {
    //     for (let i = 0; i < doc.styleSheets.length; i++) {
    //         const sheet = doc.styleSheets[i];
    //         try {
    //             if (sheet.ownerNode?.getAttribute("data-style-marker") === "dynamic") {
    //                 return sheet;
    //             }
    //         } catch (e) {
    //             console.warn("Could not access stylesheet:", sheet.href, e);
    //         }
    //     }
    //     return null;
    // }

    function populateTemplateSelector() {
        // Clear existing options (if any)
        let selector = controls.templateSelector;
        selector.innerHTML = "";

        const names = styleTemplates.getTemplateNames();

        // If currentDefault is null or falsy, call setCurrentTemplate() with no args for fallback
        if (!styleTemplates.currentDefault) {
            styleTemplates.setCurrentTemplate();
        }

        // Add options to the dropdown
        names.forEach(name => {
            const option = document.createElement("option");
            option.value = name;
            option.textContent = name;
            selector.appendChild(option);
        });

        // Set the dropdown's selected value to currentDefault (might still be null if no templates)
        if (styleTemplates.currentDefault && names.includes(styleTemplates.currentDefault)) {
            selector.value = styleTemplates.currentDefault;
        } else if (names.length > 0) {
            selector.value = names[0];
        }

        // Call once to sync constraints on an initial load
        updateControls();

        // Add change event listener after populating options
        selector.addEventListener("change", () => {
            const selected = selector.value;
            styleTemplates.setCurrentTemplate(selected);
            updateControls(true);
        });
    }

    function updateControls() {

        // Page font size
        controls.fontSize.min = styleTemplates.page.size.min;
        controls.fontSize.max = styleTemplates.page.size.max;
        controls.fontSize.step = styleTemplates.page.size.step;
        controls.fontSize.value = styleTemplates.page.size.default;

        controls.fontSizeInput.min = styleTemplates.page.size.min;
        controls.fontSizeInput.max = styleTemplates.page.size.max;
        controls.fontSizeInput.step = styleTemplates.page.size.step;
        controls.fontSizeInput.value = styleTemplates.page.size.default;

        // Header font size
        controls.headerSize.min = styleTemplates.header.size.min;
        controls.headerSize.max = styleTemplates.header.size.max;
        controls.headerSize.step = styleTemplates.header.size.step;
        controls.headerSize.value = styleTemplates.header.size.default;

        controls.headerSizeInput.min = styleTemplates.header.size.min;
        controls.headerSizeInput.max = styleTemplates.header.size.max;
        controls.headerSizeInput.step = styleTemplates.header.size.step;
        controls.headerSizeInput.value = styleTemplates.header.size.default;

        // Colors
        controls.fontColor.value = styleTemplates.page.color.default;
        controls.headerColor.value = styleTemplates.header.color.default;

        // Font families via Choices.js
        fontFamilyChoices?.setChoiceByValue(styleTemplates.page.family.default);
        headerFamilyChoices?.setChoiceByValue(styleTemplates.header.family.default);
    }

    function setupStyleControls() {
        const doc = frame.contentDocument || frame.contentWindow.document;

        const applyStyles = () => {
            const style = doc.getElementById("dynamic-style");
            style.textContent = `
        body {
          font-size: ${controls.fontSize.value}em;
          font-family: ${controls.fontFamily.value};
          color: ${controls.fontColor.value};
        }

        h1 {
          font-size: ${controls.headerSize.value}em;
          font-family: ${controls.headerFamily.value};
          color: ${controls.headerColor.value};
        }`;
        };

        const updateStyle = () => {
            applyStyles();
        };

        function resetStyleControls() {
            updateControls();
            updateStyle();
        }

        getControl("resetStyles").addEventListener("click", resetStyleControls);

        controls.fontSize.addEventListener("input", () => {
            controls.fontSizeInput.value = controls.fontSize.value;
            updateStyle();
        });
        controls.fontSizeInput.addEventListener("change", () => {
            if (typeof styleTemplates.page.clamp === "function") {
                controls.fontSizeInput.value = styleTemplates.page.clamp(parseFloat(controls.fontSizeInput.value));
            }
            controls.fontSize.value = controls.fontSizeInput.value;
            updateStyle();
        });

        controls.fontColor.addEventListener("input", updateStyle);
        controls.fontFamily.addEventListener("change", updateStyle);

        controls.headerSize.addEventListener("input", () => {
            controls.headerSizeInput.value = controls.headerSize.value;
            updateStyle();
        });
        controls.headerSizeInput.addEventListener("change", () => {
            if (typeof styleTemplates.header.clamp === "function") {
                controls.headerSizeInput.value = styleTemplates.header.clamp(parseFloat(controls.headerSizeInput.value));
            }
            controls.headerSize.value = controls.headerSizeInput.value;
            updateStyle();
        });

        controls.headerColor.addEventListener("input", updateStyle);
        controls.headerFamily.addEventListener("change", updateStyle);

        controls.templateSelector.addEventListener("change", updateStyle)

        updateControls(); // Verify controls are set to current template
        updateStyle(); // Verify applied style is the current template
    }

    function printPreview() {
        frame.contentWindow.focus();
        frame.contentWindow.print();
    }

    function saveAsPDF() {
        const srcDoc = frame.contentDocument || frame.contentWindow.document;
        const clonedDoc = srcDoc.documentElement.cloneNode(true);

        // Create a new print window
        const printWindow = window.open('', '_blank', 'width=800,height=600');

        if (!printWindow) {
            alert("Popup blocked. Please allow popups for this site.");
            return;
        }

        const printDoc = printWindow.document;
        printDoc.open();
        printDoc.write('<!DOCTYPE html><html lang="en"><head><title>Print Preview</title>');

        // Include any necessary stylesheets here
        const dynamicStyle = srcDoc.getElementById("dynamic-style");
        if (dynamicStyle) {
            printDoc.write(`<style>${dynamicStyle.textContent}</style>`);
        }

        // Optional: Add a print-specific style
        printDoc.write(`
        <style>
            @media print {
                body {
                    margin: 1in;
                }
            }
        </style>
    `);

        printDoc.write('</head><body>');
        printDoc.write(clonedDoc.querySelector('body').innerHTML);
        printDoc.write('</body></html>');
        printDoc.close();

        // Give it a moment to render
        printWindow.onload = () => {
            printWindow.focus();
            printWindow.print();
        };
    }
</script>

<script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>
<script>
    // Declare in global scope
    let fontFamilyChoices;
    let headerFamilyChoices;

    function initChoice(selector) {
        return new Choices(selector, {
            searchEnabled: true,
            itemSelectText: "",
            shouldSort: true
        });
    }

    document.addEventListener("DOMContentLoaded", () => {
        fontFamilyChoices = initChoice("#fontFamily");
        headerFamilyChoices = initChoice("#headerFamily");
    });
</script>

</body>
</html>
