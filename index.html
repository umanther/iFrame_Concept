<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>PDF Export Tool</title>

    <!-- html2pdf.js import -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

    <script type="module">
        import {setDebug} from "./scripts/debugLog.js";
        import {controlsReady, ControlTypes, generateControl} from "./scripts/controls.js";

        setDebug(false);

        await controlsReady;

        const pageSettings = document.getElementById("pageSettings");
        pageSettings.append(
            generateControl(ControlTypes.FontSize, "body", "font-size", "Font Size"),
            generateControl(ControlTypes.FontFamily, "body", "font-family", "Font"),
            generateControl(ControlTypes.Color, "body", "color", "Font Color"),
        );

        const headerSettings = document.getElementById("headerSettings");
        headerSettings.append(
            generateControl(ControlTypes.FontSize, "h1", "font-size", "Font Size"),
            generateControl(ControlTypes.FontFamily, "h1", "font-family", "Font"),
            generateControl(ControlTypes.Color, "h1", "color", "Font Color"),
        );
    </script>


    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            background-color: #ddddff;
        }

        #container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #styleControls {
            display: flex;
            flex-direction: column;
            width: 300px;
            min-height: 0;
            max-height: 100%;
            overflow: hidden;
            box-sizing: border-box;
            padding: 1em;
            background-color: #ddf;
        }

        #controlContainer {
            overflow-y: auto;
            flex-grow: 1;
            margin-bottom: 1em;
        }

        #functionButtons {
            margin-top: auto;
            padding-top: 1em;
            border-top: 1px solid #ccc;
        }

        #fontSizeInput, #headerSizeInput {
            width: 3em;
        }

        #templateSelector {
            margin-bottom: 5px;
        }

        .styleBlock {
            position: relative;
            margin-top: 1em;
            margin-bottom: .5em;
            padding: 1em .5em .5em .5em;
            border: 1px solid #888;
            border-radius: 0.5em;
        }

        .styleBlock h3 {
            position: absolute;
            top: -0.75em;
            margin-top: 0;
            margin-bottom: 0.5em;
            padding-inline: 0.25em;
            background: #ddf
        }

        iframe {
            flex-grow: 1;
            border: 2px dashed #acf;
            border-radius: 8px;
            margin: 10px;
            height: calc(100% - 20px);
        }

        .choices {
            margin-bottom: 0;
        }
    </style>
</head>
<body>

<div id="container">
    <div id="styleControls">
        <div id="controlContainer">
            <div class="styleBlock" id="pageSettings">
                <h3>Page settings</h3>
            </div>
            <div class="styleBlock" id="headerSettings">
                <h3>Header settings</h3>
            </div>
        </div>

        <div id="functionButtons">
            <button style="display: none" onclick="printPreview()">Print Preview</button>
            <button style="display: none" onclick="saveAsPDF()">Save as PDF</button>
            <label for="templateSelector">Select Style Template:<br/>
                <select id="templateSelector" data-control="templateSelector"></select><br/></label>
            <button id="resetStyles">Reset to template</button>
        </div>
    </div>

    <iframe id="previewFrame"></iframe>

</div>

<script type="module">
    import {setDebug, debugLog} from "./scripts/debugLog.js";
    import {generateID, splitID} from "./scripts/controlUtils.js";

    setDebug(true);

    class StyleTemplates {
        constructor(templates = []) {
            this.templates = templates; // Accept initial templates optionally
            this.setCurrentTemplate('Default');
        }

        // Return an array of all template names
        getTemplateNames() {
            return this.templates.map(template => template.name);
        }

        // Set currentDefault with fallback logic
        setCurrentTemplate(name) {
            const names = this.getTemplateNames();

            if (names.includes(name)) {
                this.currentDefault = name;
            } else if (names.includes('Default')) {
                this.currentDefault = 'Default';
            } else if (names.length > 0) {
                this.currentDefault = names[0];
            } else {
                this.currentDefault = null;
            }
        }

        getCurrentTemplate() {
            return this.templates.find(t => t.name === this.currentDefault) || null;
        }
    }

    function createStyleTemplatesProxy(styleTemplatesInstance) {
        return new Proxy(styleTemplatesInstance, {
            get(target, prop, receiver) {
                // If prop is a real method or property of the class, use it
                if (prop in target) {
                    return Reflect.get(target, prop, receiver);
                }

                // Otherwise, try to fetch from the current template
                const current = target.getCurrentTemplate();
                if (current && prop in current) {
                    return current[prop];
                }

                return undefined;
            }
        });
    }

    async function loadJsonFile(filename) {
        try {
            const response = await fetch(filename);
            if (response.ok) {
                const jsonString = await response.text();
                return JSON.parse(jsonString);
            } else {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
        } catch (error) {
            console.error("Error loading or parsing JSON file:", error);
            throw error;
        }
    }

    let styleTemplates; // Object to hold style templates loaded from the style-templates.json file
    let controls; // Object to hold in-page control references

    function getControl(id) {
        const el = document.getElementById(id);
        if (!el) {
            console.warn(`Missing control: #${id}`);
        }
        return el;
    }

    async function parseJsonTemplates() {
        try {
            const jsonData = await loadJsonFile('style-templates.json');

            let styleTemplatesRaw = new StyleTemplates();
            styleTemplates = createStyleTemplatesProxy(styleTemplatesRaw);

            jsonData.templates.forEach(template => {
                // Clone template and keep sections array intact
                const processed = {
                    name: template.name,
                    sections: structuredClone(template.sections)
                };

                styleTemplates.templates.push(processed);
            });
        } catch (error) {
            console.error("Failed to parse style templates:", error);
        }
    }

    function populateControls() {
        controls = Object.freeze(
            Object.fromEntries(
                Array.from(document.querySelectorAll("[data-control]")).map(el => [el.id, el])
            )
        );
        debugLog("Controls loaded:", controls);
    }

    const frame = getControl("previewFrame");

    window.onload = () => {
        frame.src = "Large HTML page with images.html";
        frame.onload = async () => {
            // Load templates from style-templates.json
            await parseJsonTemplates();

            // Populate the controls object with in-page controls for use in later functions
            populateControls();

            // Populate the template selector dropdown **before** setting up style controls
            populateTemplateSelector();

            // Then setup controls, which reads from currentDefault and sets input values
            injectStyleSheet();
        };

    };

    function injectStyleSheet() {
        const doc = frame.contentDocument || frame.contentWindow.document;

        // Make the default background white instead of transparent
        let bgColor = doc.createElement('style')
        bgColor.innerHTML = "html { background-color: white }";
        doc.head.firstChild.before(bgColor);

        // Add the style tag if it doesn't exist
        if (!doc.getElementById("dynamic-style")) {
            const style = doc.createElement("style");
            style.id = "dynamic-style";
            style.setAttribute("data-style-marker", "dynamic")
            doc.head.appendChild(style);
        }

        // Inject Google Fonts
        if (!doc.getElementById("google-fonts")) {
            doc.head.appendChild(
                Object.assign(doc.createElement('link'), {
                    rel: 'preconnect',
                    href: 'https://fonts.googleapis.com'
                })
            );
            const prelink = doc.createElement('link');
            Object.assign(prelink, {
                rel: 'preconnect',
                href: 'https://fonts.gstatic.com'
            });
            prelink.setAttribute('crossorigin', '');
            doc.head.appendChild(prelink);
            const link = doc.createElement("link");
            link.id = "google-fonts";
            link.rel = "stylesheet";
            link.href = "https://fonts.googleapis.com/css2?family=Domine&family=Inconsolata&family=Lora&family=Merriweather:opsz@18..144&family=Open+Sans&family=Roboto&display=swap";
            link.onload = setupStyleControls; // Wait for fonts to load
            doc.head.appendChild(link);
        } else {
            setupStyleControls(); // Fonts already there
        }
    }

    function populateTemplateSelector() {
        // Clear existing options (if any)
        let selector = controls.templateSelector;
        selector.innerHTML = "";

        const names = styleTemplates.getTemplateNames();

        // If currentDefault is null or falsy, call setCurrentTemplate() with no args for fallback
        if (!styleTemplates.currentDefault) {
            styleTemplates.setCurrentTemplate();
        }

        // Add options to the dropdown
        names.forEach(name => {
            const option = document.createElement("option");
            option.value = name;
            option.textContent = name;
            selector.appendChild(option);
        });

        // Set the dropdown's selected value to currentDefault (might still be null if no templates)
        if (styleTemplates.currentDefault && names.includes(styleTemplates.currentDefault)) {
            selector.value = styleTemplates.currentDefault;
        } else if (names.length > 0) {
            selector.value = names[0];
        }

        // Call once to sync constraints on an initial load
        updateControls();

        // Add change event listener after populating options
        selector.addEventListener("change", () => {
            const selected = selector.value;
            styleTemplates.setCurrentTemplate(selected);
            updateControls();
        });
    }

    function updateControls() {
        const current = styleTemplates.getCurrentTemplate();
        if (!current) return;

        for (let section of current.sections) {
            for (let cssSelector in section) {
                if (cssSelector === 'name') continue;
                for (let cssProperty in section[cssSelector]) {
                    let attributes = section[cssSelector][cssProperty]
                    let target = controls[generateID(cssSelector, cssProperty)];
                    let attribsToSet = {...attributes};
                    delete attribsToSet['type'];
                    delete attribsToSet['locked'];
                    target.locked = attributes.locked;
                    target.setDefaults(attribsToSet, true);
                }
            }
        }
    }

    function setupStyleControls() {
        const doc = frame.contentDocument || frame.contentWindow.document;

        const applyStyles = () => {
            const style = doc.getElementById("dynamic-style");

            // Get all controls from the main document
            const controlElements = [...document.querySelectorAll('[data-control]')];

            // Filter only those with a .reset() method
            const validControls = controlElements.filter(el => typeof el.reset === 'function');

            // Group declarations by CSS selector
            const grouped = {};

            for (const el of validControls) {
                const selector = el.cssSelector;
                const declaration = el.cssDeclaration;

                if (!grouped[selector]) {
                    grouped[selector] = [];
                }

                grouped[selector].push(declaration);
            }

            // Construct final stylesheet text
            // Inject into the iframe or other `doc`
            style.textContent = Object.entries(grouped)
                .map(([selector, declarations]) => `${selector} {\n  ${declarations.join(';\n  ')};\n}`)
                .join('\n\n');
        };

        const updateStyle = () => {
            applyStyles();
        };

        function resetStyleControls() {
            updateControls();
            updateStyle();
        }

        getControl("resetStyles").addEventListener("click", resetStyleControls);

        for (const control of Object.values(controls)) {
            control.addEventListener("change", updateStyle);
        }

        updateControls(); // Verify controls are set to current template
        updateStyle(); // Verify applied style is the current template
    }

    function printPreview() {
        frame.contentWindow.focus();
        frame.contentWindow.print();
    }

    function saveAsPDF() {
        const srcDoc = frame.contentDocument || frame.contentWindow.document;
        const clonedDoc = srcDoc.documentElement.cloneNode(true);

        // Create a new print window
        const printWindow = window.open('', '_blank', 'width=800,height=600');

        if (!printWindow) {
            alert("Popup blocked. Please allow popups for this site.");
            return;
        }

        const printDoc = printWindow.document;
        printDoc.open();
        printDoc.write('<!DOCTYPE html><html lang="en"><head><title>Print Preview</title>');

        // Include any necessary stylesheets here
        const dynamicStyle = srcDoc.getElementById("dynamic-style");
        if (dynamicStyle) {
            printDoc.write(`<style>${dynamicStyle.textContent}</style>`);
        }

        // Optional: Add a print-specific style
        printDoc.write(`
        <style>
            @media print {
                body {
                    margin: 1in;
                }
            }
        </style>
    `);

        printDoc.write('</head><body>');
        printDoc.write(clonedDoc.querySelector('body').innerHTML);
        printDoc.write('</body></html>');
        printDoc.close();

        // Give it a moment to render
        printWindow.onload = () => {
            printWindow.focus();
            printWindow.print();
        };
    }
</script>

</body>
</html>
