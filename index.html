<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>PDF Export Tool</title>

    <!-- html2pdf.js import -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <!-- Google Fonts (example set) -->

    <link href="https://fonts.googleapis.com/css2?family=Roboto&family=Open+Sans&family=Merriweather&family=Inconsolata&display=swap"
          rel="stylesheet">

    <!-- Choices.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css"/>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            background-color: #ddddff;
        }

        #container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #styleControls {
            display: flex;
            flex-direction: column;
            width: 300px;
            min-height: 0;
            max-height: 100%;
            overflow: hidden;
            box-sizing: border-box;
            padding: 1em;
            background-color: #ddf;
        }

        #controlContainer {
            overflow-y: auto;
            flex-grow: 1;
            margin-bottom: 1em;
        }

        #functionButtons {
            margin-top: auto;
            padding-top: 1em;
            border-top: 1px solid #ccc;
        }

        #fontSizeInput, #headerSizeInput {
            width: 3em;
        }

        #templateSelector {
            margin-bottom: 5px;
        }

        .styleBlock {
            position: relative;
            margin-top: 1em;
            margin-bottom: .5em;
            padding: 1em .5em .5em .5em;
            border: 1px solid #888;
            border-radius: 0.5em;
        }

        .styleBlock h3 {
            position: absolute;
            top: -0.75em;
            margin-top: 0;
            margin-bottom: 0.5em;
            padding-inline: 0.25em;
            background: #ddf
        }

        iframe {
            flex-grow: 1;
            border: 2px dashed #acf;
            border-radius: 8px;
            margin: 10px;
            height: calc(100% - 20px);
        }

        .choices {
            margin-bottom: 0;
        }
    </style>
</head>
<body>

<div id="container">
    <div id="styleControls">
        <div id="controlContainer">
            <div class="styleBlock">
                <h3>Page settings</h3>
                <label for="fontSize">Font Size:
                    <input type="number" id="fontSizeInput" data-control="fontSizeInput">
                    <span id="fontSizeUnit">×</span><br/>
                    <input type="range" id="fontSize" data-control="fontSize"/></label>

                <br/><br/>
                <label for="pageFamily">Font Family:
                    <select id="pageFamily" data-control="pageFamily">
                        <option value="sans-serif">Sans</option>
                        <option value="serif">Serif</option>
                        <option value="'Times New Roman', serif">Times New Roman</option>
                        <option value="monospace">Monospace</option>
                        <option value="'Roboto', sans-serif">Roboto</option>
                        <option value="'Open Sans', sans-serif">Open Sans</option>
                        <option value="'Merriweather', serif">Merriweather</option>
                        <option value="'Inconsolata', monospace">Inconsolata</option>
                        <!-- Add more fonts here -->
                    </select></label>
                <br/>
                <label for="pageColor">Text Color:
                    <input type="color" id="pageColor" data-control="pageColor"/></label>
            </div>
            <div class="styleBlock">
                <h3>Header settings</h3>
                <label for="headerSize">Font Size:
                    <input type="number" id="headerSizeInput" data-control="headerSizeInput">
                    <span id="headerSizeUnit">×</span><br/>
                    <input type="range" id="headerSize" data-control="headerSize"/></label>

                <br/><br/>
                <label for="headerFamily">Font Family:
                    <select id="headerFamily" data-control="headerFamily">
                        <option value="sans-serif">Sans</option>
                        <option value="serif">Serif</option>
                        <option value="'Times New Roman', serif">Times New Roman</option>
                        <option value="monospace">Monospace</option>
                        <option value="'Roboto', sans-serif">Roboto</option>
                        <option value="'Open Sans', sans-serif">Open Sans</option>
                        <option value="'Merriweather', serif">Merriweather</option>
                        <option value="'Inconsolata', monospace">Inconsolata</option>
                        <!-- Add more fonts here -->
                    </select>
                </label>
                <br/>
                <label for="headerColor">Text Color:
                    <input type="color" id="headerColor" data-control="headerColor"/></label>
            </div>
        </div>

        <div id="functionButtons">
            <button onclick="printPreview()">Print Preview</button>
            <button onclick="saveAsPDF()">Save as PDF</button>
            <br/><br/>
            <label for="templateSelector">Select Style Template:<br/>
                <select id="templateSelector" data-control="templateSelector"></select><br/></label>
            <button id="resetStyles">Reset to template</button>
        </div>
    </div>

    <iframe id="previewFrame"></iframe>

</div>

<script type="module">
    import {setDebug, debugLog} from "./scripts/debugLog.js";

    setDebug(true);

    class StyleTemplates {
        constructor(templates = []) {
            this.templates = templates; // Accept initial templates optionally
            this.setCurrentTemplate('Default');
        }

        // Return an array of all template names
        getTemplateNames() {
            return this.templates.map(template => template.name);
        }

        // Set currentDefault with fallback logic
        setCurrentTemplate(name) {
            const names = this.getTemplateNames();

            if (names.includes(name)) {
                this.currentDefault = name;
            } else if (names.includes('Default')) {
                this.currentDefault = 'Default';
            } else if (names.length > 0) {
                this.currentDefault = names[0];
            } else {
                this.currentDefault = null;
            }
        }

        getCurrentTemplate() {
            return this.templates.find(t => t.name === this.currentDefault) || null;
        }
    }

    function createStyleTemplatesProxy(styleTemplatesInstance) {
        return new Proxy(styleTemplatesInstance, {
            get(target, prop, receiver) {
                // If prop is a real method or property of the class, use it
                if (prop in target) {
                    return Reflect.get(target, prop, receiver);
                }

                // Otherwise, try to fetch from the current template
                const current = target.getCurrentTemplate();
                if (current && prop in current) {
                    return current[prop];
                }

                return undefined;
            }
        });
    }

    async function loadJsonFile(filename) {
        try {
            const response = await fetch(filename);
            if (response.ok) {
                const jsonString = await response.text();
                return JSON.parse(jsonString);
            } else {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
        } catch (error) {
            console.error("Error loading or parsing JSON file:", error);
            throw error;
        }
    }

    async function loadPadlockSVG() {
        try {
            const response = await fetch('assets/padlock.svg');
            const svgText = await response.text();

            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
            const svgElement = svgDoc.querySelector("svg");

            if (!svgElement) {
                throw new Error("SVG root <svg> not found");
            }

            padlockTemplate = svgElement;
            debugLog("Padlock SVG loaded:", padlockTemplate);
        } catch (error) {
            console.error("Failed to load padlock.svg:", error);
        }
    }

    // Planned to be used to populate the page with padlock controls
    function createPadlockInstance() {
        if (!padlockTemplate) {
            console.warn("Padlock template not loaded yet.");
            return null;
        }
        const padlock = padlockTemplate.cloneNode(true);

        // Attach the .lock() method to this instance
        padlock.lock = function (lockState) {
            if (lockState === 'true' || lockState === 'false') {
                this.setAttribute("data-locked", lockState);
            } else {
                // Do nothing for invalid input
                console.warn("padlock.lock() expects 'true' or 'false' as string");
            }
        };

        padlock.lock("false");

        // Add toggle behavior on click
        padlock.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();

            const currentState = padlock.getAttribute('data-locked');
            const newState = (currentState === 'true') ? 'false' : 'true';

            if (typeof padlock.lock === 'function') {
                padlock.lock(newState);
            }

            const label = padlock.nextElementSibling;
            if (!label || label.tagName.toLowerCase() !== 'label') return;

            // Disable pointer events on the label and all its child elements
            label.style.pointerEvents = newState === 'true' ? 'none' : '';
            label.style.opacity = newState === 'true' ? '0.6' : '';

            // Set aria-disabled for accessibility on the label and its descendants
            label.setAttribute('aria-disabled', newState === 'true' ? 'true' : 'false');
            label.querySelectorAll('*').forEach(el => {
                el.setAttribute('aria-disabled', newState === 'true' ? 'true' : 'false');
            });
        });


        return padlock;
    }

    function insertPadlocks() {
        if (!padlockTemplate) {
            console.warn("Padlock SVG not loaded yet.");
            return;
        }

        const labels = document.querySelectorAll(".styleBlock label");

        labels.forEach(label => {
            // Prevent double insertion by checking if previous sibling is a padlock
            if (label.previousElementSibling?.classList.contains("padlock")) return;

            const padlock = createPadlockInstance();
            if (!padlock) return;

            padlock.classList.add("padlock");
            padlock.style.width = "1em";
            padlock.style.height = "1em";
            padlock.style.verticalAlign = "middle";
            padlock.style.marginRight = "0.3em";
            padlock.style.cursor = "pointer";
            padlock.style.userSelect = "none";

            // Prevent padlock from hijacking focus or click behavior
            ['mousedown', 'click', 'dblclick'].forEach(evt =>
                padlock.addEventListener(evt, e => {
                    e.preventDefault();
                    e.stopPropagation();
                })
            );

            // Insert the padlock directly before the label
            label.parentNode.insertBefore(padlock, label);
        });

        debugLog("Padlocks inserted before all labels.");
    }

    function applyLockToPadlock(controlEl, lockState) {
        if (!controlEl || (lockState !== 'true' && lockState !== 'false')) return;

        const label = controlEl.closest('label');
        if (!label) {
            console.warn('Control element has no enclosing label:', controlEl);
            return;
        }

        const padlock = label.previousElementSibling;
        if (!padlock || !padlock.classList.contains("padlock")) {
            console.warn('Padlock not found before label for control:', controlEl);
            return;
        }

        if (typeof padlock.lock === 'function') {
            padlock.lock(lockState);
            const isLocked = lockState === 'true';

            // Disable or enable all interactive children in the label
            const elementsToToggle = label.querySelectorAll('input, select, textarea, button');
            elementsToToggle.forEach(el => el.disabled = isLocked);
        } else {
            console.warn('Padlock does not have a .lock() method:', padlock);
        }
    }

    let styleTemplates; // Object to hold style templates loaded from the style-templates.json file
    let controls; // Object to hold in-page control references
    let padlockTemplate; // Template variable of padlock.svg

    function getControl(id) {
        const el = document.getElementById(id);
        if (!el) {
            console.warn(`Missing control: #${id}`);
        }
        return el;
    }

    async function parseJsonTemplate() {
        function addClampIfNeeded(section) {
            if (
                section &&
                section.size &&
                typeof section.size.min === "number" &&
                typeof section.size.max === "number"
            ) {
                section.clamp = function (value) {
                    return Math.min(Math.max(value, this.size.min), this.size.max);
                };
            }
        }

        try {
            const jsonData = await loadJsonFile('style-templates.json');

            // Create a new StyleTemplates object
            let styleTemplatesRaw = new StyleTemplates();
            styleTemplates = createStyleTemplatesProxy(styleTemplatesRaw);

            // Iterate over each template
            jsonData.templates.forEach(template => {
                const processed = {name: template.name};

                Object.entries(template).forEach(([sectionName, sectionData]) => {
                    if (sectionName === "name") return;

                    const section = structuredClone(sectionData);
                    addClampIfNeeded(section);
                    processed[sectionName] = section;
                });

                styleTemplates.templates.push(processed);
            });
        } catch
            (error) {
            console.error("Failed to parse style templates:", error);
        }
    }

    function populateControls() {
        controls = Object.freeze(
            Object.fromEntries(
                Array.from(document.querySelectorAll("[data-control]")).map(el => [el.dataset.control, el])
            )
        );
        debugLog("Controls loaded:", controls);
    }

    const frame = getControl("previewFrame");

    window.onload = () => {
        frame.src = "Large HTML page with images.html";
        frame.onload = async () => {
            // Load templates from style-templates.json
            await parseJsonTemplate();

            // Load padlock.svg into global variable
            await loadPadlockSVG();

            // Populate the controls object with in-page controls for use in later functions
            populateControls();

            // Insert padlocks to use to lock controls
            insertPadlocks();

            // Populate the template selector dropdown **before** setting up style controls
            populateTemplateSelector();

            // Then setup controls, which reads from currentDefault and sets input values
            injectStyleSheet();
        };

    };

    function injectStyleSheet() {
        const doc = frame.contentDocument || frame.contentWindow.document;

        // Make the default background white instead of transparent
        let bgColor = doc.createElement('style')
        bgColor.innerHTML = "html { background-color: white }";
        doc.head.firstChild.before(bgColor);

        // Add the style tag if it doesn't exist
        if (!doc.getElementById("dynamic-style")) {
            const style = doc.createElement("style");
            style.id = "dynamic-style";
            style.setAttribute("data-style-marker", "dynamic")
            doc.head.appendChild(style);
        }

        // Inject Google Fonts
        if (!doc.getElementById("google-fonts")) {
            const link = doc.createElement("link");
            link.id = "google-fonts";
            link.rel = "stylesheet";
            link.href = "https://fonts.googleapis.com/css2?family=Roboto&family=Open+Sans&family=Merriweather&family=Inconsolata&display=swap";
            link.onload = setupStyleControls; // Wait for fonts to load
            doc.head.appendChild(link);
        } else {
            setupStyleControls(); // Fonts already there
        }
    }

    // function findStyleSheetWithMarker(doc) {
    //     for (let i = 0; i < doc.styleSheets.length; i++) {
    //         const sheet = doc.styleSheets[i];
    //         try {
    //             if (sheet.ownerNode?.getAttribute("data-style-marker") === "dynamic") {
    //                 return sheet;
    //             }
    //         } catch (e) {
    //             console.warn("Could not access stylesheet:", sheet.href, e);
    //         }
    //     }
    //     return null;
    // }

    function populateTemplateSelector() {
        // Clear existing options (if any)
        let selector = controls.templateSelector;
        selector.innerHTML = "";

        const names = styleTemplates.getTemplateNames();

        // If currentDefault is null or falsy, call setCurrentTemplate() with no args for fallback
        if (!styleTemplates.currentDefault) {
            styleTemplates.setCurrentTemplate();
        }

        // Add options to the dropdown
        names.forEach(name => {
            const option = document.createElement("option");
            option.value = name;
            option.textContent = name;
            selector.appendChild(option);
        });

        // Set the dropdown's selected value to currentDefault (might still be null if no templates)
        if (styleTemplates.currentDefault && names.includes(styleTemplates.currentDefault)) {
            selector.value = styleTemplates.currentDefault;
        } else if (names.length > 0) {
            selector.value = names[0];
        }

        // Call once to sync constraints on an initial load
        updateControls();

        // Add change event listener after populating options
        selector.addEventListener("change", () => {
            const selected = selector.value;
            styleTemplates.setCurrentTemplate(selected);
            updateControls();
        });
    }

    function updateControls() {

        // Page font size
        controls.fontSize.min = styleTemplates.page.size.min;
        controls.fontSize.max = styleTemplates.page.size.max;
        controls.fontSize.step = styleTemplates.page.size.step;
        controls.fontSize.value = styleTemplates.page.size.default;

        applyLockToPadlock(controls.fontSize, 'true');

        controls.fontSizeInput.min = styleTemplates.page.size.min;
        controls.fontSizeInput.max = styleTemplates.page.size.max;
        controls.fontSizeInput.step = styleTemplates.page.size.step;
        controls.fontSizeInput.value = styleTemplates.page.size.default;

        // Header font size
        controls.headerSize.min = styleTemplates.header.size.min;
        controls.headerSize.max = styleTemplates.header.size.max;
        controls.headerSize.step = styleTemplates.header.size.step;
        controls.headerSize.value = styleTemplates.header.size.default;

        controls.headerSizeInput.min = styleTemplates.header.size.min;
        controls.headerSizeInput.max = styleTemplates.header.size.max;
        controls.headerSizeInput.step = styleTemplates.header.size.step;
        controls.headerSizeInput.value = styleTemplates.header.size.default;

        // Colors
        controls.pageColor.value = styleTemplates.page.color.default;
        controls.headerColor.value = styleTemplates.header.color.default;

        // Font families via Choices.js
        pageFamilyChoices?.setChoiceByValue(styleTemplates.page.family.default);
        headerFamilyChoices?.setChoiceByValue(styleTemplates.header.family.default);
    }

    function setupStyleControls() {
        const doc = frame.contentDocument || frame.contentWindow.document;

        const applyStyles = () => {
            const style = doc.getElementById("dynamic-style");
            style.textContent = `
        body {
          font-size: ${controls.fontSize.value}em;
          font-family: ${controls.pageFamily.value};
          color: ${controls.pageColor.value};
        }

        h1 {
          font-size: ${controls.headerSize.value}em;
          font-family: ${controls.headerFamily.value};
          color: ${controls.headerColor.value};
        }`;
        };

        const updateStyle = () => {
            applyStyles();
        };

        function resetStyleControls() {
            updateControls();
            updateStyle();
        }

        getControl("resetStyles").addEventListener("click", resetStyleControls);

        controls.fontSize.addEventListener("input", () => {
            controls.fontSizeInput.value = controls.fontSize.value;
            updateStyle();
        });
        controls.fontSizeInput.addEventListener("change", () => {
            if (typeof styleTemplates.page.clamp === "function") {
                controls.fontSizeInput.value = styleTemplates.page.clamp(parseFloat(controls.fontSizeInput.value));
            }
            controls.fontSize.value = controls.fontSizeInput.value;
            updateStyle();
        });

        controls.pageColor.addEventListener("input", updateStyle);
        controls.pageFamily.addEventListener("change", updateStyle);

        controls.headerSize.addEventListener("input", () => {
            controls.headerSizeInput.value = controls.headerSize.value;
            updateStyle();
        });
        controls.headerSizeInput.addEventListener("change", () => {
            if (typeof styleTemplates.header.clamp === "function") {
                controls.headerSizeInput.value = styleTemplates.header.clamp(parseFloat(controls.headerSizeInput.value));
            }
            controls.headerSize.value = controls.headerSizeInput.value;
            updateStyle();
        });

        controls.headerColor.addEventListener("input", updateStyle);
        controls.headerFamily.addEventListener("change", updateStyle);

        controls.templateSelector.addEventListener("change", updateStyle)

        updateControls(); // Verify controls are set to current template
        updateStyle(); // Verify applied style is the current template
    }

    function printPreview() {
        frame.contentWindow.focus();
        frame.contentWindow.print();
    }

    function saveAsPDF() {
        const srcDoc = frame.contentDocument || frame.contentWindow.document;
        const clonedDoc = srcDoc.documentElement.cloneNode(true);

        // Create a new print window
        const printWindow = window.open('', '_blank', 'width=800,height=600');

        if (!printWindow) {
            alert("Popup blocked. Please allow popups for this site.");
            return;
        }

        const printDoc = printWindow.document;
        printDoc.open();
        printDoc.write('<!DOCTYPE html><html lang="en"><head><title>Print Preview</title>');

        // Include any necessary stylesheets here
        const dynamicStyle = srcDoc.getElementById("dynamic-style");
        if (dynamicStyle) {
            printDoc.write(`<style>${dynamicStyle.textContent}</style>`);
        }

        // Optional: Add a print-specific style
        printDoc.write(`
        <style>
            @media print {
                body {
                    margin: 1in;
                }
            }
        </style>
    `);

        printDoc.write('</head><body>');
        printDoc.write(clonedDoc.querySelector('body').innerHTML);
        printDoc.write('</body></html>');
        printDoc.close();

        // Give it a moment to render
        printWindow.onload = () => {
            printWindow.focus();
            printWindow.print();
        };
    }
</script>

<script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>
<script src="scripts/applyChoicesClass.js"></script>

</body>
</html>
