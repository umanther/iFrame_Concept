<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>PDF Export Tool</title>

    <!-- html2pdf.js import -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <!-- Google Fonts (example set) -->

    <link href="https://fonts.googleapis.com/css2?family=Roboto&family=Open+Sans&family=Merriweather&family=Inconsolata&display=swap"
          rel="stylesheet">

    <!-- Choices.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css"/>

    <style>
        body {
            font-family: sans-serif;
            background-color: #f8f8f8;
            margin: 2em;
        }

        #container {
            display: flex;
            gap: 1em;
        }

        #styleControls {
            flex: 0 0 250px;
            padding: .5em;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 0.5em;
        }

        #fontSizeInput, #headerSizeInput {
            width: 3em;
        }

        #templateSelector {
            margin-bottom: 5px;
        }

        .styleBlock {
            border: 1px solid #888;
            border-radius: 0.5em;
            padding: .5em;
            margin-bottom: .5em;
        }

        .styleBlock h3 {
            margin-bottom: 0.5em;
            margin-top: 0;
        }

        iframe {
            flex-grow: 1;
            height: 600px;
            border: 1px solid #ccc;
            background: #fff;
        }

        .choices {
            margin-bottom: 0;
        }
    </style>
</head>
<body>

<h1>PDF Export Tool</h1>
<div id="container">
    <div id="styleControls">
        <div class="styleBlock">
            <h3>Page settings</h3>
            <label for="fontSize">Font Size: <input type="number" id="fontSizeInput"><span
                    id="fontSizeUnit">Ã—</span></label><br/>
            <input type="range" id="fontSize"/>

            <br/><br/>
            <label for="fontFamily">Font Family:</label>
            <select id="fontFamily">
                <option value="sans-serif">Sans</option>
                <option value="serif">Serif</option>
                <option value="monospace">Monospace</option>
                <option value="'Roboto', sans-serif">Roboto</option>
                <option value="'Open Sans', sans-serif">Open Sans</option>
                <option value="'Merriweather', serif">Merriweather</option>
                <option value="'Inconsolata', monospace">Inconsolata</option>
                <!-- Add more fonts here -->
            </select>
            <br/>
            <label>Text Color: <input type="color" id="textColor"/></label>
        </div>
        <div class="styleBlock">
            <h3>Header settings</h3>
            <label for="headerSize">Font Size: <input type="number" id="headerSizeInput"><span
                    id="headerSizeUnit">Ã—</span></label><br/>
            <input type="range" id="headerSize"/>

            <br/><br/>
            <label for="headerFamily">Font Family:</label>
            <select id="headerFamily">
                <option value="sans-serif">Sans</option>
                <option value="serif">Serif</option>
                <option value="monospace">Monospace</option>
                <option value="'Roboto', sans-serif">Roboto</option>
                <option value="'Open Sans', sans-serif">Open Sans</option>
                <option value="'Merriweather', serif">Merriweather</option>
                <option value="'Inconsolata', monospace">Inconsolata</option>
                <!-- Add more fonts here -->
            </select>
            <br/>
            <label for="headerColor">Text Color: </label>
            <input type="color" id="headerColor"/>
        </div>

        <button onclick="printPreview()">Print Preview</button>
        <button onclick="saveAsPDF()">Save as PDF</button>
        <br/><br/>
        <label for="templateSelector">Select Style Template:</label><br />
        <select id="templateSelector"></select><br />
        <button id="resetStyles">Reset to template</button>

    </div>

    <iframe id="previewFrame"></iframe>
</div>

<script>
    class StyleTemplates {
        constructor(templates = []) {
            this.templates = templates; // Accept initial templates optionally
            this.setCurrentTemplate('Default');
        }

        // Return an array of all template names
        getTemplateNames() {
            return this.templates.map(template => template.name);
        }

        // Set currentDefault with fallback logic
        setCurrentTemplate(name) {
            const names = this.getTemplateNames();

            if (names.includes(name)) {
                this.currentDefault = name;
            } else if (names.includes('Default')) {
                this.currentDefault = 'Default';
            } else if (names.length > 0) {
                this.currentDefault = names[0];
            } else {
                this.currentDefault = null;
            }
        }

        getCurrentTemplate() {
            return this.templates.find(t => t.name === this.currentDefault) || null;
        }
    }

    function createStyleTemplatesProxy(styleTemplatesInstance) {
        return new Proxy(styleTemplatesInstance, {
            get(target, prop, receiver) {
                // If prop is a real method or property of the class, use it
                if (prop in target) {
                    return Reflect.get(target, prop, receiver);
                }

                // Otherwise, try to fetch from the current template
                const current = target.getCurrentTemplate();
                if (current && prop in current) {
                    return current[prop];
                }

                return undefined;
            }
        });
    }

    async function loadJsonFile(filename) {
        try {
            const response = await fetch(filename);
            if (response.ok) {
                const jsonString = await response.text();
                return JSON.parse(jsonString);
            } else {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
        } catch (error) {
            console.error("Error loading or parsing JSON file:", error);
            throw error;
        }
    }

    let styleTemplates;

    async function parseJsonTemplate() {
        function addClampIfNeeded(section) {
            if (
                section &&
                section.size &&
                typeof section.size.min === "number" &&
                typeof section.size.max === "number"
            ) {
                section.clamp = function (value) {
                    return Math.min(Math.max(value, this.size.min), this.size.max);
                };
            }
        }

        try {
            const jsonData = await loadJsonFile('style-templates.json');

            // Create a new StyleTemplates object
            let styleTemplatesRaw = new StyleTemplates();
            styleTemplates = createStyleTemplatesProxy(styleTemplatesRaw);

            // Iterate over each template
            jsonData.templates.forEach(template => {
                const processed = {name: template.name};

                Object.entries(template).forEach(([sectionName, sectionData]) => {
                    if (sectionName === "name") return;

                    const section = structuredClone(sectionData);
                    addClampIfNeeded(section);
                    processed[sectionName] = section;
                });

                styleTemplates.templates.push(processed);
            });
        } catch
            (error) {
            console.error("Failed to parse style templates:", error);
        }
    }

    const frame = document.getElementById("previewFrame");
    window.onload = () => {
        frame.src = "Large HTML page with images.html";
        frame.onload = async () => {
            await parseJsonTemplate();

            // Populate the template selector dropdown **before** setting up style controls
            populateTemplateSelector();

            // Then setup controls, which reads from currentDefault and sets input values
            injectStyleSheet();
        };

    };

    function injectStyleSheet() {
        const doc = frame.contentDocument || frame.contentWindow.document;

        // Add the style tag if it doesn't exist
        if (!doc.getElementById("dynamic-style")) {
            const style = doc.createElement("style");
            style.id = "dynamic-style";
            style.setAttribute("data-style-marker", "dynamic")
            doc.head.appendChild(style);

        }

        // Inject Google Fonts
        if (!doc.getElementById("google-fonts")) {
            const link = doc.createElement("link");
            link.id = "google-fonts";
            link.rel = "stylesheet";
            link.href = "https://fonts.googleapis.com/css2?family=Roboto&family=Open+Sans&family=Merriweather&family=Inconsolata&display=swap";
            link.onload = setupStyleControls; // ðŸŸ¢ Wait for fonts to load
            doc.head.appendChild(link);
        } else {
            setupStyleControls(); // Fonts already there
        }
    }

    function findStyleSheetWithMarker(doc) {
        for (let i = 0; i < doc.styleSheets.length; i++) {
            const sheet = doc.styleSheets[i];
            try {
                if (sheet.ownerNode?.getAttribute("data-style-marker") === "dynamic") {
                    return sheet;
                }
            } catch (e) {
                console.warn("Could not access stylesheet:", sheet.href, e);
            }
        }
        return null;
    }

    function populateTemplateSelector() {
        const selector = document.getElementById("templateSelector");
        // Clear existing options (if any)
        selector.innerHTML = "";

        const names = styleTemplates.getTemplateNames();

        // If currentDefault is null or falsy, call setCurrentTemplate() with no args for fallback
        if (!styleTemplates.currentDefault) {
            styleTemplates.setCurrentTemplate();
        }

        // Add options to the dropdown
        names.forEach(name => {
            const option = document.createElement("option");
            option.value = name;
            option.textContent = name;
            selector.appendChild(option);
        });

        // Set the dropdown's selected value to currentDefault (might still be null if no templates)
        if (styleTemplates.currentDefault && names.includes(styleTemplates.currentDefault)) {
            selector.value = styleTemplates.currentDefault;
        } else if (names.length > 0) {
            selector.value = names[0];
        }

        function updateControlsConstraints() {
            const fontSize = document.getElementById("fontSize");
            const fontSizeInput = document.getElementById("fontSizeInput");
            const headerSize = document.getElementById("headerSize");
            const headerSizeInput = document.getElementById("headerSizeInput");

            // Update page sliders constraints
            if (styleTemplates.page && styleTemplates.page.size) {
                //TODO: Change this so it loads all template defaults.  All values should be updated.
                fontSize.value = styleTemplates.page.clamp(fontSize.value);
                fontSize.min = styleTemplates.page.size.min;
                fontSize.max = styleTemplates.page.size.max;
                fontSize.step = styleTemplates.page.size.step;

                fontSizeInput.value = styleTemplates.page.clamp(fontSizeInput.value);
                fontSizeInput.min = styleTemplates.page.size.min;
                fontSizeInput.max = styleTemplates.page.size.max;
                fontSizeInput.step = styleTemplates.page.size.step;

                // Trigger input event to apply styles
                fontSize.dispatchEvent(new Event("input"));
                fontSizeInput.dispatchEvent(new Event("change"));
            }

            // Update header sliders constraints
            if (styleTemplates.header && styleTemplates.header.size) {
                headerSize.value = styleTemplates.header.clamp(headerSize.value);
                headerSize.min = styleTemplates.header.size.min;
                headerSize.max = styleTemplates.header.size.max;
                headerSize.step = styleTemplates.header.size.step;

                headerSizeInput.value = styleTemplates.header.clamp(headerSizeInput.value);
                headerSizeInput.min = styleTemplates.header.size.min;
                headerSizeInput.max = styleTemplates.header.size.max;
                headerSizeInput.step = styleTemplates.header.size.step;

                // Trigger input event to apply styles
                headerSize.dispatchEvent(new Event("input"));
                headerSizeInput.dispatchEvent(new Event("change"));
            }
            // Note: Do NOT change slider or input .value properties here
        }

        // Call once to sync constraints on an initial load
        updateControlsConstraints();

        // Add change event listener after populating options
        selector.addEventListener("change", () => {
            const selected = selector.value;
            styleTemplates.setCurrentTemplate(selected);
            updateControlsConstraints();
        });
    }


    function setupStyleControls() {
        const doc = frame.contentDocument || frame.contentWindow.document;

        const fontSize = document.getElementById("fontSize");
        const fontSizeInput = document.getElementById("fontSizeInput");
        const fontFamily = document.getElementById("fontFamily");
        const textColor = document.getElementById("textColor");

        const headerSize = document.getElementById("headerSize");
        const headerSizeInput = document.getElementById("headerSizeInput");
        const headerFamily = document.getElementById("headerFamily");
        const headerColor = document.getElementById("headerColor");

        // Font size range + input
        fontSize.min = styleTemplates.page.size.min;
        fontSize.max = styleTemplates.page.size.max;
        fontSize.step = styleTemplates.page.size.step;
        fontSize.value = styleTemplates.page.size.default;
        fontSizeInput.min = styleTemplates.page.size.min;
        fontSizeInput.max = styleTemplates.page.size.max;
        fontSizeInput.step = styleTemplates.page.size.step;
        fontSizeInput.value = styleTemplates.page.size.default;

        // Header size range + input
        headerSize.min = styleTemplates.header.size.min;
        headerSize.max = styleTemplates.header.size.max;
        headerSize.step = styleTemplates.header.size.step;
        headerSize.value = styleTemplates.header.size.default;
        headerSizeInput.min = styleTemplates.header.size.min;
        headerSizeInput.max = styleTemplates.header.size.max;
        headerSizeInput.step = styleTemplates.header.size.step;
        headerSizeInput.value = styleTemplates.header.size.default;

        // Colors
        textColor.value = styleTemplates.page.color.default;
        headerColor.value = styleTemplates.header.color.default;

        // Font families (dropdowns)
        fontFamilyChoices.setChoiceByValue(styleTemplates.page.family.default);
        headerFamilyChoices.setChoiceByValue(styleTemplates.header.family.default);

        const applyStyles = () => {
            const style = doc.getElementById("dynamic-style");
            style.textContent = `
        body {
          font-size: ${fontSize.value}em;
          font-family: ${fontFamily.value};
          color: ${textColor.value};
        }

        h1 {
          font-size: ${headerSize.value}em;
          font-family: ${headerFamily.value};
          color: ${headerColor.value};
        }`;
        };

        const updateStyle = () => {
            applyStyles();
        };

        function resetStyleControls() {
            fontSize.value = styleTemplates.page.size.default;
            fontSizeInput.value = styleTemplates.page.size.default;
            headerSize.value = styleTemplates.header.size.default;
            headerSizeInput.value = styleTemplates.header.size.default;

            textColor.value = styleTemplates.page.color.default;
            headerColor.value = styleTemplates.header.color.default;

            fontFamilyChoices.setChoiceByValue(styleTemplates.page.family.default);
            headerFamilyChoices.setChoiceByValue(styleTemplates.header.family.default);

            updateStyle();
        }

        document.getElementById("resetStyles").addEventListener("click", resetStyleControls);

        fontSize.addEventListener("input", () => {
            fontSizeInput.value = fontSize.value;
            updateStyle();
        });
        fontSizeInput.addEventListener("change", () => {
            if (typeof styleTemplates.page.clamp === "function") {
                fontSizeInput.value = styleTemplates.page.clamp(parseFloat(fontSizeInput.value));
            }
            fontSize.value = fontSizeInput.value;
            updateStyle();
        });

        textColor.addEventListener("input", updateStyle);
        fontFamily.addEventListener("change", updateStyle);

        headerSize.addEventListener("input", () => {
            headerSizeInput.value = headerSize.value;
            updateStyle();
        });
        headerSizeInput.addEventListener("change", () => {
            if (typeof styleTemplates.header.clamp === "function") {
                headerSizeInput.value = styleTemplates.header.clamp(parseFloat(headerSizeInput.value));
            }
            headerSize.value = headerSizeInput.value;
            updateStyle();
        });

        headerColor.addEventListener("input", updateStyle);
        headerFamily.addEventListener("change", updateStyle);
    }

    function printPreview() {
        frame.contentWindow.focus();
        frame.contentWindow.print();
    }

    function saveAsPDF() {
        const srcDoc = frame.contentDocument || frame.contentWindow.document;
        const clonedDoc = srcDoc.documentElement.cloneNode(true);

        // Create a new print window
        const printWindow = window.open('', '_blank', 'width=800,height=600');

        if (!printWindow) {
            alert("Popup blocked. Please allow popups for this site.");
            return;
        }

        const printDoc = printWindow.document;
        printDoc.open();
        printDoc.write('<!DOCTYPE html><html lang="en"><head><title>Print Preview</title>');

        // Include any necessary stylesheets here
        const dynamicStyle = srcDoc.getElementById("dynamic-style");
        if (dynamicStyle) {
            printDoc.write(`<style>${dynamicStyle.textContent}</style>`);
        }

        // Optional: Add a print-specific style
        printDoc.write(`
        <style>
            @media print {
                body {
                    margin: 1in;
                }
            }
        </style>
    `);

        printDoc.write('</head><body>');
        printDoc.write(clonedDoc.querySelector('body').innerHTML);
        printDoc.write('</body></html>');
        printDoc.close();

        // Give it a moment to render
        printWindow.onload = () => {
            printWindow.focus();
            printWindow.print();
        };
    }
</script>

<script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>
<script>
    // Declare in global scope
    let fontFamilyChoices;
    let headerFamilyChoices;

    document.addEventListener("DOMContentLoaded", function () {
        fontFamilyChoices = new Choices("#fontFamily", {
            searchEnabled: true,
            itemSelectText: "",
            shouldSort: true
        });

        headerFamilyChoices = new Choices("#headerFamily", {
            searchEnabled: true,
            itemSelectText: "",
            shouldSort: true
        });
    });
</script>

</body>
</html>
